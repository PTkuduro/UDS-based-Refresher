#### ISO15765的部分内容在下载工具代码中的实现

* ##### 前言

在我的理解当中,下载工具当中应用的ISO15765有三个功能：  
（1）为应用层提供服务：Request、Confirm、Indication

（2）为上层提供接口实现数据交流：分段、重组与流控制

（3）网络层中的时间控制：STmin、N\_As等  
这三个部分构成了网络层协议的整体，从而为对等实体间的CAN通信提供了基础，

###### （1）服务原语

SocketCAN提供了一个非常好的通信接口：  
`write(s, &frame, sizeof(frame));`的返回值是发送的字节，如果不为0，则发送成功（Confirm服务与Request服务）  
`read(s, &frame, sizeof(frame));`的返回值是接收的字节，如果不为0，接收成功（Indication服务）

###### （2）数据流控制

在网络层中定义了初始化FF与CF的函数

```c
void Frame_Init_FF(struct can_frame* frame,uint32_t byte_send)
{
        frame->can_id=FF_ID;
        frame->can_dlc=8;
        frame->data[0]=0xf&(byte_send>>8);
        frame->data[0]|=0x10;
        frame->data[1]=0xff&byte_send;
}
void Frame_Init_CF(struct can_frame* Frame,int Frame_Count){//Frame已被分配内存
    for(int i=0;i<Frame_Count;i++)
    {
        Frame[i].can_id = FF_ID;
        Frame[i].data[0] = GLOBAL_SN;
        Frame[i].can_dlc = 8;
        GLOBAL_SN++;
        if (GLOBAL_SN > 0x2F)
            GLOBAL_SN=0x20;
    }
}
```
以及发送和接收的函数，通过函数指针调用
```c
int indi_FC(struct can_frame* pf, char service)
{	
	int bytes;
	bytes = read(s, pf, sizeof(*pf));
	while ((pf->data[0] != 0x30))
	{
		bytes = read(s, pf, sizeof(*pf)); 
	}
	if (bytes)
		return 1;
	else
		return -1;
}

int indi_SF(struct can_frame* pf, char service)
{
	int bytes;
	bytes = read(s, pf, sizeof(*pf));
	while((pf->data[3])==0x78&&(pf->data[1]==0x7F))
		bytes = read(s, pf, sizeof(*pf));
	if (bytes)
		return 1;
	else 
		return -1;
		
}
int req_SF(struct can_frame* pf)
{	int byte = 0;
	byte=write(s, pf, sizeof(*pf));
	if (((pf->data[0] & 0xF0) == 0x00&&byte>0)||((pf->data[0] & 0xF0) == 0x10&&byte>0))
		return 1;
	else 
		return -1;
}	
int req_CF(struct can_frame* pf)
{
	int byte = 0;
	byte = write(s, pf, sizeof(*pf));
	if ((pf->data[0]&0xF0) == 0x20&&byte>0)
		return 1;
	else 
		return -1;
}
```
###### （3) 定时参数
由于对定时的要求不是很高，我只在发送报文的网络层循环中实现了STmin：





